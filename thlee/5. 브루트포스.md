# 브루트포스

**브루트포스(Brute Force)** 알고리즘은 가능한 모든 경우의 수를 무작위로 전부 탐색하여 해답을 찾는 방법입니다. 이 방법은 문제를 해결할 수 있는 가장 단순하고 기본적인 접근 방식입니다. 하지만 경우의 수가 많을수록 시간이 많이 소요되며, 매우 비효율적일 수 있습니다.

## 브루트포스의 주요 특징

- ```모든 경우의 수를 전부 탐색```: 최선, 최악, 평균 케이스 상관없이 모든 경우를 시도합니다.
- ```비효율적일 수 있음```: 가능한 모든 조합을 확인하기 때문에 계산 비용이 크고, 시간이 오래 걸릴 수 있습니다.
- ```간단한 구현```: 복잡한 알고리즘 설계 없이, 문제 해결을 위해 가능한 모든 경우를 반복적으로 시도하기 때문에 구현이 쉽습니다.
- ```최적 해를 찾을 수 있음```: 모든 경우를 탐색하므로 최적 해답을 보장합니다.


## 브루트포스 알고리즘 예시
문제를 해결하기 위한 브루트포스 방법은 가능한 해답들을 전부 시도하며, 이를 통해 원하는 답을 찾습니다. 예를 들어, 특정한 비밀번호를 찾기 위해 가능한 모든 비밀번호를 시도해보는 것이 브루트포스의 대표적인 예입니다.

### 예시 1: 1부터 N까지의 수 중에서 주어진 합을 만드는 두 수 찾기

두 수의 합이 주어진 target과 같은 조합을 찾는 간단한 브루트포스 예제입니다.

```python
def brute_force_sum(arr, target):
    n = len(arr)
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i] + arr[j] == target:
                return (arr[i], arr[j])
    return None

# 예시 사용
arr = [2, 7, 11, 15]
target = 9
result = brute_force_sum(arr, target)
print(result)  # 출력: (2, 7)
```

이 예제에서는 배열 내의 두 수의 합이 주어진 target과 같을 때 그 두 수를 반환하는 브루트포스 방식입니다. 모든 가능한 두 수의 조합을 검사하므로 O(n^2) 시간이 소요됩니다.

### 예시 2: 문자열의 모든 순열 생성 (Brute Force로 순열 탐색)

다음은 문자열의 모든 순열을 브루트포스 방식으로 생성하는 예시입니다.

```python
from itertools import permutations

def brute_force_permutations(s):
    perm_list = [''.join(p) for p in permutations(s)]
    return perm_list

# 예시 사용
s = "abc"
result = brute_force_permutations(s)
print(result)  # 출력: ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
```

이 코드는 주어진 문자열의 모든 순열을 생성합니다. 가능한 모든 조합을 탐색하는 방식이므로, 경우의 수가 많아질수록 시간 복잡도가 급격히 증가합니다.

## 브루트포스의 장단점

### 장점

- 간단한 구현: 복잡한 논리나 자료구조 없이 문제를 해결할 수 있습니다.
- 정확한 해답 보장: 모든 경우를 탐색하기 때문에 항상 정확한 해를 찾을 수 있습니다.

### 단점

- 비효율적: 경우의 수가 많을 경우, 시간 복잡도가 매우 커져 실행 시간이 기하급수적으로 증가할 수 있습니다.
- 실제 문제에 적용하기 어려울 수 있음: 문제의 크기나 복잡성에 따라 브루트포스 알고리즘은 실제 문제 해결에 적합하지 않을 수 있습니다.

## 언제 브루트포스를 사용할까?
- 문제 크기가 작을 때
- 다른 효율적인 알고리즘을 찾기 어려울 때
- 최적화된 알고리즘을 설계하기 전, 문제의 작동 방식을 이해하기 위한 초기 접근으로 사용


브루트포스는 직관적이고 간단한 방법이지만, 경우에 따라 더 나은 알고리즘을 찾는 것이 중요합니다.