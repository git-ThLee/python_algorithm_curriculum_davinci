# 그리디

**그리디(Greedy)** 알고리즘은 매 순간마다 당장 최선의 선택(즉, 가장 최적이라고 생각되는 선택)을 하는 방식으로 문제를 해결하는 알고리즘입니다. 이 알고리즘은 문제 해결을 위해 여러 단계에서 가능한 선택 중 하나를 선택하며, 각 단계에서 선택이 다음 단계에도 영향을 미칩니다. 그리디 알고리즘은 선택 과정에서 한번 선택한 것이 다시 변경되지 않으며, 이러한 선택이 문제의 전체적인 최적 해답을 보장할 수 있을 때 유용합니다.


## 그리디 알고리즘의 주요 특징

- ```국소 최적화```: 각 단계에서 가장 좋은 선택을 함으로써 전체 문제의 최적해를 도출하려고 시도합니다.
- ```단순한 구현```: 문제를 작은 부분으로 나누어 각각을 독립적으로 해결하는 방식이기 때문에 비교적 간단하게 구현할 수 있습니다.
- ```최적해를 항상 보장하지는 않음```: 그리디 알고리즘은 항상 전체 문제에 대한 최적해를 보장하지는 않으며, 일부 문제에서는 부분적으로만 유효합니다. 이를 위해선 문제의 구조가 '그리디 선택 속성'을 가져야 합니다.

## 그리디 알고리즘의 핵심

- 그리디 선택 속성(Greedy Choice Property): 각 단계에서 그리디 선택이 최적해로 이어질 수 있는 속성.
- 최적 부분 구조(Optimal Substructure): 문제의 최적해가 부분 문제의 최적해로 구성될 수 있는 성질.

## 그리디 알고리즘 사용 조건
- 문제의 최적해가 각 단계에서의 국소 최적해를 통해 이루어질 수 있는 경우.
- 선택이 다음 선택에 영향을 미치지 않는 경우.

## 그리디 알고리즘의 예시

### 1. 거스름돈 문제

거스름돈을 줄 때, 가장 적은 동전 수를 사용하여 거스름돈을 주는 문제입니다. 이 문제에서는 큰 단위의 동전부터 차례대로 거슬러 주는 것이 최적해를 보장합니다.

예시 코드 (거스름돈 문제)
```python
def greedy_coin_change(total, coins):
    coins.sort(reverse=True)  # 큰 단위의 동전부터 탐색
    result = []
    for coin in coins:
        while total >= coin:
            total -= coin
            result.append(coin)
    return result

# 예시 사용
total = 1260
coins = [500, 100, 50, 10]
result = greedy_coin_change(total, coins)
print(f"Coins used: {result}")  # 출력: [500, 500, 100, 100, 50, 10]
```

이 예시에서는 1260원을 거슬러 줄 때, 500원짜리 동전 2개, 100원짜리 동전 2개, 50원짜리 동전 1개, 10원짜리 동전 1개를 사용합니다. 그리디 알고리즘이 최적해를 보장할 수 있는 이유는 각 동전이 다른 동전의 배수이기 때문입니다.

### 2. 활동 선택 문제

다양한 활동이 있고, 각 활동은 특정 시작 시간과 종료 시간이 주어집니다. 한 사람이 동시에 여러 활동을 할 수 없을 때, 가장 많은 활동을 선택할 수 있도록 하려면 어떻게 해야 할까요? 이 문제는 그리디 알고리즘을 사용하여 해결할 수 있습니다.

예시 코드 (활동 선택 문제)

```python
def greedy_activity_selector(activities):
    # 종료 시간을 기준으로 오름차순 정렬
    activities.sort(key=lambda x: x[1])
    
    # 첫 번째 활동을 선택
    selected = [activities[0]]
    
    # 이전에 선택된 활동의 종료 시간
    last_finish_time = activities[0][1]
    
    for i in range(1, len(activities)):
        if activities[i][0] >= last_finish_time:  # 현재 활동의 시작 시간이 이전 활동의 종료 시간 이후일 때
            selected.append(activities[i])
            last_finish_time = activities[i][1]  # 현재 활동의 종료 시간을 업데이트
            
    return selected

# 예시 사용
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)]
result = greedy_activity_selector(activities)
print(f"Selected activities: {result}")  
# 출력: Selected activities: [(1, 4), (5, 7), (8, 11), (12, 14)]
```

이 예시에서는 종료 시간이 가장 빠른 활동부터 선택하는 것이 최적해를 보장합니다. 활동이 겹치지 않도록 선택하여 최대한 많은 활동을 선택하는 방식입니다.

## 그리디 알고리즘의 장단점

### 장점

- 빠르고 간단함: 일반적으로 그리디 알고리즘은 구현이 매우 간단하며, 계산 복잡도도 낮은 편입니다.
- 적용 가능한 문제에서는 최적의 해를 제공: 특정 조건을 만족하는 문제에서는 항상 최적의 해를 제공합니다.

### 단점

- 최적해 보장이 어려움: 모든 문제에서 최적해를 보장하지 않기 때문에, 그리디 알고리즘이 적합한지 검증해야 합니다.
- 국소 최적해와 전체 최적해의 차이: 어떤 문제에서는 그리디 선택이 국소적으로는 최적이지만, 전체적으로는 최적해가 아닐 수 있습니다.


## 그리디 알고리즘을 적용할 수 있는 문제 유형

- 거스름돈 문제 (동전이 특정한 배수일 때)
- 최소 신장 트리(MST) (프림 또는 크루스칼 알고리즘)
- 최소 비용으로 작업 스케줄링
- 최대 활동 선택 문제


그리디 알고리즘은 매우 유용하지만, 항상 최적해를 보장하지 않기 때문에 문제의 특성에 따라 적용해야 합니다. 최적화 문제가 아닌 경우나 특정 조건을 만족할 때만 사용해야 합니다.