# 시간복잡도 (Time Complexity)

## 1. 정의

**시간복잡도(Time Complexity)** 는 알고리즘이 처리해야 하는 입력의 크기(n)에 따라 실행되는 연산의 횟수를 측정한 것으로, 알고리즘의 효율성을 판단하는 중요한 척도입니다. 주로 **빅오(Big-O) 표기법**을 사용하여 나타냅니다.

### 주요 시간복잡도 종류
- **O(1)**: 상수 시간, 입력 크기에 상관없이 일정한 시간.
- **O(log n)**: 로그 시간, 입력 크기가 커질수록 실행 시간이 천천히 증가.
- **O(n)**: 선형 시간, 입력 크기에 비례해 실행 시간 증가.
- **O(n²)**: 이차 시간, 입력 크기에 따라 실행 시간이 제곱에 비례해 증가.

## 2. 예시

### O(1): 상수 시간 복잡도
```python
# 리스트의 첫 번째 요소를 출력하는 함수
def print_first_element(arr):
    # 항상 첫 번째 요소만 출력하므로 상수 시간 복잡도 O(1)
    print(arr[0])

# 현실 비교: 냉장고에서 가장 앞에 있는 물건을 집는 것과 같음.
```

### O(n): 선형 시간 복잡도

```python
# 리스트의 모든 요소를 출력하는 함수
def print_all_elements(arr):
    for element in arr:
        # 리스트의 모든 요소를 출력하므로 O(n)
        print(element)

# 현실 비교: 책상에 펼쳐진 n개의 종이를 하나씩 확인하는 것과 같음.
```

### O(n²): 이차 시간 복잡도

```python
# 모든 쌍의 요소를 비교하는 함수
def print_all_pairs(arr):
    for i in range(len(arr)):
        for j in range(len(arr)):
            # 이중 반복문이므로 시간복잡도는 O(n^2)
            print(arr[i], arr[j])

# 현실 비교: n명의 학생이 서로 악수를 하는 것과 같음. 각 학생은 n번의 악수를 해야 함.
```

## 3. 시간복잡도

시간복잡도는 프로그램이 동작하는데 걸리는 시간을 기준으로 한다.

프로그램이 동작할 때 기본적인 연산(+, -, *, / 등)에도 시간이 필요하지만 변수에 값을 저장, 할당하는 행위에 비해 매우 적은 시간이 필요하므로 시간복잡도를 계산할 때는 무시한다.

즉, 변수에 값이 할당되는 동작을 기준으로 시간복잡도를 계산한다.

대략 1억번의 연산이 있을 경우 약 1초의 시간이 필요하다.

### 예시

```python
a = 0
for i in range(n):
    a += 1
```

위의 코드에서는 a = 0 에서 1번,

i에 차례로 0 ~ n-1 까지 저장되는 횟수 n번

a += 1에서 더해서 a에 저장되는 횟수 n번

따라서 시간복잡도는 2n + 1로 나타낸다.


## 4. 현실에 비교한 시간복잡도

### O(1) - 상수 시간

냉장고에서 가장 앞에 있는 물건을 바로 집는 행동. 어떤 상황에서든지 바로 첫 번째 물건을 집을 수 있으므로 시간이 항상 일정합니다.

### O(n) - 선형 시간

책상에 놓인 n개의 종이를 차례대로 하나씩 확인하는 과정. 종이의 개수가 많아질수록 확인하는 시간이 그에 비례해 길어집니다.

### O(n²) - 이차 시간

모든 학생들이 서로 악수를 하는 상황을 상상해보세요. 만약 n명의 학생이 있다면, 각 학생은 다른 모든 학생과 악수를 해야 하므로 총 n²번의 악수가 필요하게 됩니다.


## 4. 빅오(Big-O) 표기법

시간복잡도를 나타내는 가장 널리 쓰이는 표기법은 빅오(Big-O) 표기법입니다. 빅오 표기법은 알고리즘의 성능이 최악의 경우에 얼마나 많은 시간이 소요될지 설명해 줍니다.

### 예시

#### O(1): 입력 크기와 상관없이 일정한 시간이 걸림. (예: 배열에서 첫 번째 요소를 찾는 경우)

#### O(n): 입력 크기에 비례하여 시간이 증가. (예: 리스트의 모든 요소를 순회하는 경우)

#### O(n²): 입력 크기의 제곱에 비례해 시간이 증가. (예: 두 배열에서 모든 요소를 비교하는 경우)

### 현실에서의 중요성

프로그램이 작은 데이터셋을 다룰 때는 시간복잡도가 크게 중요하지 않지만, 데이터가 많아지면 시간복잡도가 효율성을 좌우하는 큰 요소가 됩니다. 예를 들어, 1000개의 데이터를 처리할 때 O(n²) 알고리즘은 1,000,000번의 연산을 필요로 하며, 이는 비효율적입니다.

## 결론
시간복잡도는 알고리즘의 성능을 평가하는 중요한 지표로, 입력의 크기가 커질수록 알고리즘이 얼마나 효율적으로 작동하는지를 나타냅니다. 이를 잘 이해하고 효율적인 알고리즘을 선택하는 것은 개발자가 해결해야 할 중요한 과제입니다.